void Persona:: popola_max_min_angolo_zenit(int _angolo){
	map<int,list<Angolo>>::iterator iter;
	max_min_angoli_zenit.erase(max_min_angoli_zenit.begin(), max_min_angoli_zenit.end());
 iter= sequenzaangolo.find(_angolo);
    if(iter!=sequenzaangolo.end()){
		int size = iter->second.size();
		double mediazenit = media_zenit(iter->second);
		double devst = devst_zenit(iter->second);
		int max_confronto = (int)200/ devst;
		int how=0;//massimo->how=1 //minimo->how=2 //cresce o descresce->how=0
	//	bool exit_value = 0; //massimo o minimo->bool=1 //niente->bool=0

		
        list<Angolo>::iterator iterl;
		list<Angolo>::iterator a_iterl;//after
		list<Angolo>::iterator b_iterl;//before
		list<Angolo>::iterator na_iterl;
		list<Angolo>::iterator nb_iterl;

		//inserisco il primo elemento con max/min relativo??
		int contl=1,cont1=1,cont2;
        for(iterl=++(iter->second.begin());iterl!=--(iter->second.end());iterl++){
		//	cont1 = contl;
			cont2 = 2;//parte da 2 poich� entro nel while solo nel momento in cui vado ad analizzare le due celle successive o pi�
			//inizializzo iteratori
			how = 0;
			int dove = 0;//sinistra->1 //destra->2 //entrambi->3 //valore iniziale->0 //altro->4
			a_iterl = iterl;
			a_iterl++;
			b_iterl = iterl;
			b_iterl--;
			na_iterl = iterl;
			nb_iterl = iterl;
			Angolo a = *(a_iterl);
			Angolo b = *(b_iterl);
			Angolo na = *(na_iterl);
			Angolo nb = *(nb_iterl);
			Angolo n = *(iterl);


			if (na.get_zenit() > a.get_zenit() && nb.get_zenit() > b.get_zenit()) {
				how = 1;
			//	iterl++;
			//	contl++;
			}
			if (na.get_zenit() < a.get_zenit() && nb.get_zenit() < b.get_zenit()) {
				how = 2;
			//	iterl++;
			//	contl++;
			}
				
			while (cont2 < (size - cont1) && (cont1-cont2>=0) && cont2 <= max_confronto && how!=0){
				a_iterl++;	b_iterl--;	
				//na_iterl++;	nb_iterl--;
				a = *(a_iterl);	b = *(b_iterl);	na = *(na_iterl);	nb = *(nb_iterl);

				if ((how==1 && na.get_zenit() > a.get_zenit() && nb.get_zenit() > b.get_zenit())||((how == 2 && na.get_zenit() < a.get_zenit() && nb.get_zenit() < b.get_zenit()))) {
				//	iterl++;
				//	contl++;
					cont2++;
				}
				else {
					how = 0;
				}
			/*	if (how == 1) {//massimo ipotetico
					if (na.get_zenit() > a.get_zenit() && nb.get_zenit() > b.get_zenit() && (dove == 0 || dove == 3)){
						dove = 3;
					}
					else {
						if (na.get_zenit() > a.get_zenit() && (dove == 0 || dove == 2 || dove == 3)) {
							dove = 2;
							//puoi guardare a destra
						}
						else {
							if (nb.get_zenit() > b.get_zenit() && (dove == 0 || dove == 1 || dove == 3)) {
								dove = 1;
								//puoi guardare a sinistra
							}
							else {
								dove = 4;
							}
						}
					}
				}
				if (how == 2) {//minimo ipotetico
					if (na.get_zenit() < a.get_zenit() && nb.get_zenit() < b.get_zenit() && (dove == 0 || dove == 3)) {
						dove = 3;
					}
					else {
						if (na.get_zenit() < a.get_zenit() && (dove == 0 || dove == 2 || dove == 3)) {
							dove = 2;
							//puoi guardare a destra
						}
						else {
							if (nb.get_zenit() < b.get_zenit() && (dove == 0 || dove == 1 || dove == 3)) {
								dove = 1;
								//puoi guardare a sinistra
							}
							else {
								dove = 4;
							}
						}
					}
				}


				if (dove != 4) {
					cont2++;
				}
				else{
					how = 0;
				}
			*/	
			}
			if (how != 0) {
				max_min_angoli_zenit[_angolo].insert(n.get_numeroframe());
			}

			cont1++;
			//contl++;
		
        }
    }else{
        cout<<"Angolo "<<_angolo<<" non trovato."<<endl;
    }
}

void Persona::popola_max_min_angolo_azimut(int _angolo){
	map<int, list<Angolo>>::iterator iter;
	max_min_angoli_azimut.erase(max_min_angoli_azimut.begin(), max_min_angoli_azimut.end());
	iter = sequenzaangolo.find(_angolo);
	if (iter != sequenzaangolo.end()) {
		int size = iter->second.size();
		double mediaazimut = media_azimut(iter->second);
		double devst = devst_azimut(iter->second);
		int max_confronto = (int)500 / devst;
		int how = 0;//massimo->how=1 //minimo->how=2 //cresce o descresce->how=0
	//	bool exit_value = 0; //massimo o minimo->bool=1 //niente->bool=0


		list<Angolo>::iterator iterl;
		list<Angolo>::iterator a_iterl;//after
		list<Angolo>::iterator b_iterl;//before
		list<Angolo>::iterator na_iterl;
		list<Angolo>::iterator nb_iterl;

		//inserisco il primo elemento con max/min relativo??
		int contl = 1, cont1 = 1, cont2;
		for (iterl = ++(iter->second.begin()); iterl != --(iter->second.end()); iterl++) {
			//	cont1 = contl;
			cont2 = 2;//parte da 2 poich� entro nel while solo nel momento in cui vado ad analizzare le due celle successive o pi�
			//inizializzo iteratori
			how = 0;
			int dove = 0;//sinistra->1 //destra->2 //entrambi->3 //valore iniziale->0 //altro->4
			a_iterl = iterl;
			a_iterl++;
			b_iterl = iterl;
			b_iterl--;
			na_iterl = iterl;
			nb_iterl = iterl;
			Angolo a = *(a_iterl);
			Angolo b = *(b_iterl);
			Angolo na = *(na_iterl);
			Angolo nb = *(nb_iterl);
			Angolo n = *(iterl);


			if (na.get_azimut() > a.get_azimut() && nb.get_azimut() > b.get_azimut()) {
				how = 1;
				//	iterl++;
				//	contl++;
			}
			if (na.get_azimut() < a.get_azimut() && nb.get_azimut() < b.get_azimut()) {
				how = 2;
				//	iterl++;
				//	contl++;
			}

			while (cont2 < (size - cont1) && (cont1 - cont2 > 0) && cont2 <= max_confronto && how != 0) {
				a_iterl++;	b_iterl--;
				//na_iterl++;	nb_iterl--;
				a = *(a_iterl);	b = *(b_iterl);	na = *(na_iterl);	nb = *(nb_iterl);

				if (how == 1) {//massimo ipotetico
					if (na.get_zenit() > a.get_zenit() && nb.get_zenit() > b.get_zenit() && (dove == 0 || dove == 3)){
						dove = 3;
					}
					else {
						if (na.get_zenit() > a.get_zenit() && (dove == 0 || dove == 2 || dove == 3)) {
							dove = 2;
							//puoi guardare a destra
						}
						else {
							if (nb.get_zenit() > b.get_zenit() && (dove == 0 || dove == 1 || dove == 3)) {
								dove = 1;
								//puoi guardare a sinistra
							}
							else {
								dove = 4;
							}
						}
					}
				}
				if (how == 2) {//minimo ipotetico
					if (na.get_zenit() < a.get_zenit() && nb.get_zenit() < b.get_zenit() && (dove == 0 || dove == 3)) {
						dove = 3;
					}
					else {
						if (na.get_zenit() < a.get_zenit() && (dove == 0 || dove == 2 || dove == 3)) {
							dove = 2;
							//puoi guardare a destra
						}
						else {
							if (nb.get_zenit() < b.get_zenit() && (dove == 0 || dove == 1 || dove == 3)) {
								dove = 1;
								//puoi guardare a sinistra
							}
							else {
								dove = 4;
							}
						}
					}
				}


				if (dove != 4) {
					cont2++;
				}

			/*
				if ((how == 1 && na.get_zenit() > a.get_zenit() && nb.get_zenit() > b.get_zenit()) || ((how == 2 && na.get_zenit() < a.get_zenit() && nb.get_zenit() < b.get_zenit()))) {
					//	iterl++;
					//	contl++;
					cont2++;
				}*/

				else {
					how = 0;
				}

			}
			if (how != 0) {
				max_min_angoli_azimut[_angolo].insert(n.get_numeroframe());
			}

			cont1++;
			//contl++;

		}
	}
	else {
		cout << "Angolo " << _angolo << " non trovato." << endl;
	}

	void Persona::kamazenit_lista(int _angolo, int period, int fast_period, int slow_period) {//kaufman's adaptive moving average
	map<int, list<Angolo>>::iterator iter;
	list<Angolo>::iterator iterl;
	list<Angolo>::iterator iterl_b;
	int cont = 0;
	iter = sequenzaangoloelab.find(_angolo);
	if (iter != sequenzaangoloelab.end()) {
		for (iterl = (iter->second).begin(); iterl != (iter->second).end(); iterl++) {
			if (cont > period) {
				iterl_b = iterl;
				iterl_b--;
				Angolo a = *(iterl);
				Angolo b = *(iterl_b);
				double fast = (2 / ((double)(fast_period + 1)));
				double slow = (2 /( (double)(slow_period + 1)));
				double sc = ERi_zenit(_angolo, cont, period)*(fast - slow) + slow;
				double res = (b.get_zenit() + pow(sc,2) * (a.get_zenit() - b.get_zenit()));
				(*iterl).set_zenit(res);
			//	cout << sc << endl;
			}	
			cont++;
		}
	}
	else {
		cout << "Angolo " << _angolo << " non trovato." << endl;
	} 
}

void Persona::kamaazimut_lista(int _angolo, int period, int fast_period, int slow_period) {//kaufman's adaptive moving average
	map<int, list<Angolo>>::iterator iter;
	list<Angolo>::iterator iterl;
	list<Angolo>::iterator iterl_b;
	int cont = 0;
	iter = sequenzaangoloelab.find(_angolo);
	if (iter != sequenzaangoloelab.end()) {
		for (iterl = (iter->second).begin(); iterl != (iter->second).end(); iterl++) {
			if (cont > period) {
				iterl_b = iterl;
				iterl_b--;
				Angolo a = *(iterl);
				Angolo b = *(iterl_b);
				double fast = (2 / ((double)(fast_period + 1)));
				double slow = (2 / ((double)(slow_period + 1)));
				double sc = ERi_azimut(_angolo, cont, period)*(fast - slow) + slow;
				double res = (b.get_azimut() + pow(sc,2) * (a.get_azimut() - b.get_azimut()));
				(*iterl).set_azimut(res);
				//	cout << sc << endl;
			}
			cont++;
		}
	}
	else {
		cout << "Angolo " << _angolo << " non trovato." << endl;
	}
}
}long double Persona::ERi_zenit(int _angolo,int i,int n) {
	
	map<int, list<Angolo>>::const_iterator iter;
	list<Angolo>::const_iterator iterl;
	list<Angolo>::const_iterator iterl_1;
	list<Angolo>::const_iterator iterl_n;
	int cont = 0;
	long double den=0.0, num;
	iter = sequenzaangoloelab.find(_angolo);
	if (iter != sequenzaangoloelab.end()) {
		cont = 0;
		//faccio avanzare ad i-n il mio iteratore // fxcodebase.com/wiki/index.php/Kaufman's_Adaptive_Moving_Average_(KAMA)
		
		for (iterl = (iter->second).begin(); (iterl != (iter->second).end() && cont < (i-n)); iterl++) {
			cont++;
		}
		Angolo ang_n = *(iterl);
		Angolo ang = *(iterl);
		iterl_1 = iterl;
		iterl_1--;
		Angolo ang_1 = *(iterl_1);
		
		while (iterl != (iter->second).end() && cont<(i)) {
			ang = *(iterl);
			iterl_1 = iterl;
			iterl_1--;
			ang_1 = *(iterl_1);
			den = fabs(ang.get_zenit() - ang_1.get_zenit()) + den;
			iterl++;
			cont++;
		}
		num = fabs(ang.get_zenit() - ang_n.get_zenit());
		return num / den;
	}
	else {
		cout << "Angolo " << _angolo << " non trovato." << endl;
		return 0;
	}
}

long double Persona::ERi_azimut(int _angolo, int i, int n) {

	map<int, list<Angolo>>::const_iterator iter;
	list<Angolo>::const_iterator iterl;
	list<Angolo>::const_iterator iterl_1;
	list<Angolo>::const_iterator iterl_n;
	int cont = 0;
	long double den = 0.0, num;
	iter = sequenzaangoloelab.find(_angolo);
	if (iter != sequenzaangoloelab.end()) {
		cont = 0;
		//faccio avanzare ad i-n il mio iteratore // fxcodebase.com/wiki/index.php/Kaufman's_Adaptive_Moving_Average_(KAMA)

		for (iterl = (iter->second).begin(); (iterl != (iter->second).end() && cont < (i - n)); iterl++) {
			cont++;
		}
		Angolo ang_n = *(iterl);
		Angolo ang = *(iterl);
		iterl_1 = iterl;
		iterl_1--;
		Angolo ang_1 = *(iterl_1);

		while (iterl != (iter->second).end() && cont < (i)) {
			ang = *(iterl);
			iterl_1 = iterl;
			iterl_1--;
			ang_1 = *(iterl_1);
			den = fabs(ang.get_azimut() - ang_1.get_azimut()) + den;
			iterl++;
			cont++;
		}
		num = fabs(ang.get_azimut() - ang_n.get_azimut());
		return num / den;
	}
	else {
		cout << "Angolo " << _angolo << " non trovato." << endl;
		return 0;
	}
}